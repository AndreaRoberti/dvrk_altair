/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-    */
/* ex: set filetype=cpp softtabstop=4 shiftwidth=4 tabstop=4 cindent expandtab: */

/*
  
  Author(s):  Peter Kazanzides
  Created on: 2016-04-29
  
  (C) Copyright 2016 Johns Hopkins University (JHU), All Rights Reserved.

--- begin cisst license - do not edit ---

This software is provided "as is" under an open source license, with
no warranty.  The complete license can be found in license.txt and
http://www.cisst.org/cisst/license.txt.

--- end cisst license ---
*/

#include <cisstVector/vctDynamicVectorTypes.h>

#include "nmrLinearRegressionTest.h"

// Following Y values generated by Y = 150*X + 25 + round(10*rand()-5),
// where X = 0..24 and rand() returns a random number between 0 and 1.
static int Y1[] = {21, 173, 323, 476, 630, 777, 921, 1078, 1224, 1378, 1528, 1673, 1829, 1971, 2125,
                   2273, 2427, 2570, 2721, 2872, 3020, 3172, 3328, 3479, 3620};
// Following ground-truth values computed by Excel (LINEST).
static double slope1 = 149.924615384615;
static double yint1 = 25.2646153846151;
static double mse1 = 10.3348923076932;

// Ground-truth values for above with moving window size of 7
static double slope_mw7[] = { 0, 152, 151, 151.5, 152.1, 151.542857142857, 150.535714285714, 150.428571428571000,
                              149.928571428571, 149.821428571429, 149.964285714286, 150.071428571429, 150.642857142857,
                              149.428571428571, 149.642857142857, 149.178571428571, 149.75, 149.607142857143,
                              149.142857142857, 149.714285714286, 149.178571428571, 149.464285714286, 150.214285714286,
                              151.464285714286, 150.678571428571 };

static double yint_mw7[] = { 0, 21, 21.3333333333333, 21, 20.4, 21.1428571428572, 22.8214285714287, 23.7142857142858,
                             25.9285714285714, 27.3571428571432, 26.8214285714287, 25.0000000000002, 20.0714285714289,
                             31.5714285714282, 29.3571428571429, 35.1428571428573, 28.3928571428571, 29.5000000000005,
                             36.5714285714289, 27.2857142857142, 36.5357142857142, 31.7857142857151, 18.7857142857147,
                             -6.14285714285643, 8.892857142858250 };

static double mse_mw7[] =  { 0, 0, 0.222222222222218, 0.374999999999993, 1.02, 2.05714285714283, 8.5255102040817,
                             8.0816326530612, 8.22448979591828, 7.50510204081646, 7.95408163265301, 7.08163265306105,
                             6.75510204081646, 7.10204081632651, 7.16326530612268, 5.50510204081638, 7.30102040816313,
                             8.23979591836761, 6.97959183673436, 5.02040816326529, 3.26020408163263, 3.83163265306138,
                             9.08163265306114, 3.54591836734697, 10.2806122448979 };

template <class _vectorType>
void nmrLinearRegressionTest::TestLinearRegression(void)
{
    typedef typename _vectorType::value_type ElementType;
    typedef typename nmrLinearRegressionSolver<ElementType>::SummationType SummationType;
    bool isIntegralType = (cmnTypeTraits<ElementType>::MinPositiveValue() == 1);
    ElementType tol = cmnTypeTraits<ElementType>::Tolerance();

    _vectorType x(20);
    _vectorType y(20);
    size_t i;
    ElementType slope, yint, mse;
    SummationType slope_num, yint_num, denom, tse_num;
    bool ret;

    // First, test with perfect data (no noise)
    for (i = 0; i < x.size(); i++) {
        x[i] = static_cast<ElementType>(i);
        y[i] = static_cast<ElementType>(i)*23 - 18;
    }
    ret = nmrLinearRegression(x, y, slope, yint, &mse);
    CPPUNIT_ASSERT(ret);
    if (isIntegralType) {
        CPPUNIT_ASSERT(slope == 23);
        CPPUNIT_ASSERT(yint == -18);
        CPPUNIT_ASSERT(mse == 0);
        nmrLinearRegressionSolver<ElementType> solver;
        CPPUNIT_ASSERT(solver.Sample(x,y));
        CPPUNIT_ASSERT(solver.EstimateAsFractions(slope_num, yint_num, denom, &tse_num));
        double slopef = static_cast<double>(slope_num)/static_cast<double>(denom);
        double yintf = static_cast<double>(yint_num)/static_cast<double>(denom);
        double msef = static_cast<double>(tse_num)/static_cast<double>(denom*solver.NumPoints());
        double tolf = cmnTypeTraits<double>::Tolerance();
        CPPUNIT_ASSERT((23-tolf <= slopef) && (slopef <= 23+tolf));
        CPPUNIT_ASSERT((-18-tolf <= yintf) && (yintf <= -18+tolf));
        CPPUNIT_ASSERT((-tolf <= msef) && (msef <= tolf));
    }
    else {
        CPPUNIT_ASSERT((23-tol <= slope) && (slope <= 23+tol));
        CPPUNIT_ASSERT((-18-tol <= yint) && (yint <= -18+tol));
        CPPUNIT_ASSERT((-tol <= mse) && (mse <= tol));
    }

    // Now, try with noisy data
    x.resize(sizeof(Y1)/sizeof(Y1[0]));
    y.resize(sizeof(Y1)/sizeof(Y1[0]));
    for (i = 0; i < x.size(); i++) {
        x[i] = static_cast<ElementType>(i);
        y[i] = static_cast<ElementType>(Y1[i]);
    }
    ret = nmrLinearRegression(x, y, slope, yint, &mse);
    CPPUNIT_ASSERT(ret);
    if (isIntegralType) {
        CPPUNIT_ASSERT(slope == static_cast<ElementType>(slope1));
        CPPUNIT_ASSERT(yint == static_cast<ElementType>(yint1));
        nmrLinearRegressionSolver<ElementType> solver;
        CPPUNIT_ASSERT(solver.Sample(x,y));
        CPPUNIT_ASSERT(solver.EstimateAsFractions(slope_num, yint_num, denom, &tse_num));
        double slopef = static_cast<double>(slope_num)/static_cast<double>(denom);
        double yintf = static_cast<double>(yint_num)/static_cast<double>(denom);
        double msef = static_cast<double>(tse_num)/static_cast<double>(denom*solver.NumPoints());;
        double tolf = cmnTypeTraits<double>::Tolerance();
        CPPUNIT_ASSERT((slope1-tolf <= slopef) && (slopef <= slope1+tolf));
        CPPUNIT_ASSERT((yint1-tolf <= yintf) && (yintf <= yint1+tolf));
        CPPUNIT_ASSERT((mse1-tolf <= msef) && (msef <= mse1+tolf));
    }
    else {
        CPPUNIT_ASSERT((slope1-tol <= slope) && (slope <= slope1+tol));
        CPPUNIT_ASSERT((yint1-tol <= yint) && (yint <= yint1+tol));
        CPPUNIT_ASSERT((mse1-tol <= mse) && (mse <= mse1+tol));
    }

    // Test moving window
    const int WINDOW_SIZE = 7;
    nmrLinearRegressionWindowSolver<ElementType> solverWindow(WINDOW_SIZE);
    CPPUNIT_ASSERT(solverWindow.WindowLength() == WINDOW_SIZE);
    TestMovingWindow(&solverWindow, x, y);

    nmrLinearRegressionWindowRecursiveSolver<ElementType> solverWindowRecursive(WINDOW_SIZE);
    CPPUNIT_ASSERT(solverWindowRecursive.WindowLength() == WINDOW_SIZE);
    TestMovingWindow(&solverWindowRecursive, x, y);

    // Finally, verify that we detect vertical lines (infinite slope),
    // in which case nmrLinearRegression should return false.
    x.resize(10);
    y.resize(10);
    for (i = 0; i < x.size(); i++) {
        x[i] = static_cast<ElementType>(10);
        y[i] = static_cast<ElementType>(i);
    }
    ret = nmrLinearRegression(x, y, slope, yint, &mse);
    CPPUNIT_ASSERT(!ret);
    // Now test solver; Estimate should return false, whereas EstimateAsFractions
    // will work, but denom should be 0.
    nmrLinearRegressionSolver<ElementType> solver;
    CPPUNIT_ASSERT(solver.Sample(x,y));
    CPPUNIT_ASSERT(!solver.Estimate(slope,yint, &mse));
    CPPUNIT_ASSERT(solver.EstimateAsFractions(slope_num, yint_num, denom, &tse_num));
    if (isIntegralType)
        CPPUNIT_ASSERT(denom == 0);
    else
        CPPUNIT_ASSERT((-tol <= denom) && (denom <= tol));
}

template <class _vectorType>
void nmrLinearRegressionTest::TestMovingWindow(nmrLinearRegressionWindowSolver<typename _vectorType::value_type> *solver,
                                               _vectorType x, _vectorType y)
{
    typedef typename _vectorType::value_type ElementType;
    typedef typename nmrLinearRegressionSolver<ElementType>::SummationType SummationType;
    bool isIntegralType = (cmnTypeTraits<ElementType>::MinPositiveValue() == 1);
    ElementType tol = cmnTypeTraits<ElementType>::Tolerance();

    CPPUNIT_ASSERT(solver->Sample(x[0], y[0]));
    CPPUNIT_ASSERT(solver->NumPoints() == 1);
    for (size_t i = 1; i < x.size(); i++) {
        CPPUNIT_ASSERT(solver->Sample(x[i], y[i]));
        CPPUNIT_ASSERT(solver->NumPoints() == ((i < solver->WindowLength()) ? i+1 : solver->WindowLength()));
        if (isIntegralType) {
            SummationType slope_num, yint_num, denom, tse_num;
            solver->EstimateAsFractions(slope_num, yint_num, denom, &tse_num);
            CPPUNIT_ASSERT((denom < -tol) || (denom > tol));
            double slopef = static_cast<double>(slope_num)/static_cast<double>(denom);
            double yintf = static_cast<double>(yint_num)/static_cast<double>(denom);
            double msef = static_cast<double>(tse_num)/static_cast<double>(denom*solver->NumPoints());;
            double tolf = cmnTypeTraits<double>::Tolerance();
            CPPUNIT_ASSERT((slope_mw7[i]-tolf <= slopef) && (slopef <= slope_mw7[i]+tolf));
            CPPUNIT_ASSERT((yint_mw7[i]-tolf <= yintf) && (yintf <= yint_mw7[i]+tolf));
            CPPUNIT_ASSERT((mse_mw7[i]-tolf <= msef) && (msef <= mse_mw7[i]+tolf));
        }
        else {
            ElementType slope, yint, mse;
            solver->Estimate(slope, yint, &mse);
            CPPUNIT_ASSERT((slope_mw7[i]-tol <= slope) && (slope <= slope_mw7[i]+tol));
            CPPUNIT_ASSERT((yint_mw7[i]-tol <= yint) && (yint <= yint_mw7[i]+tol));
            CPPUNIT_ASSERT((mse_mw7[i]-tol <= mse) && (mse <= mse_mw7[i]+tol));
        }
    }
}

void nmrLinearRegressionTest::TestLinearRegression_vctDoubleVec(void)
{
    TestLinearRegression<vctDoubleVec>();
}

void nmrLinearRegressionTest::TestLinearRegression_vctIntVec(void)
{
    TestLinearRegression<vctIntVec >();
}

void nmrLinearRegressionTest::TestLinearRegression_StdVecDouble(void)
{
    TestLinearRegression<std::vector<double> >();
}

void nmrLinearRegressionTest::TestLinearRegression_StdVecInt(void)
{
    TestLinearRegression<std::vector<int> >();
}

CPPUNIT_TEST_SUITE_REGISTRATION(nmrLinearRegressionTest);
